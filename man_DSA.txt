

Finding kth largest
    keep record of the number of children a node has (in addition to the left pointer and the right pointer).
    now we have been asked to find the 50th largest. we are at a node and we see that my right child has 15 children.
    all 15 children and this node are more than me. so lets traverse to the left node and look for the 35th largest node


Sorting a Linked List: A good discussion
    merge would be most efective. its inplace. O(nlogn).
    caveat: breaking the list into two roughly equal parts may not be feasible in case the list is
    arbitrarily large. traversing whole list would invite n potential cache misses
    somewhat awesome solution: sort first 2 elements. sort next two elements.
                               sort the first two and next two using merge sort. 4 elements got sorted.
			       sort similarly the next 4 and merge the first 4 and next 4 elements. get 8 sorted elements
			       ... (implement this).
			       O(nlogn) comparisons. stack would use O(logn) space due to recursion
    how is cache misses reduced. we are anyway doing nlogn traveral ultimately.
    check: http://jonisalonen.com/2013/sorting-a-linked-list/

    A linked list can have memory allocation anywhere in the virtual address space..
    iterating through an LL can be very expensive in paging / caching.
    sorting a linked list is not a good idea. be it merge sort or bubble or counting sort.
    probably in a huge dataset, copying the whole set into an array, purge the LL (space saved)
    then sort the array (better memory localization)
    practically this turns out to be faster on normal PCs much due to ..
    localization on a million elements with high fragmentation
    check: http://stackoverflow.com/questions/1525117/whats-the-fastest-algorithm-for-sorting-a-linked-list
    packed list and fragmented list ??

    Or just copy the linked list into a new list. rather recreate the linked list into a new
    Data Structure like a BST (simplest case, or another list) and keep on sorting tree as each element is inserted.
    simultaneously keep freeing the corresponding element from the older list

    inplace, O(n) ?? really


BST insertion complexity is O(n^2)   in case of a  badly balanced tree where the tree turns into a linked list
                            O(nlogn) in case of a fairly balanced tree


Searching a smaller string into a bigger string.
    Use iteration to go throug the first characters in the bigger string. and once found a match use recursion to
    determine if the subsequent characters match. Should work efficiently in cases where we are searching
    ssshit in holysssssshittt.


Tree traversals. Find maximum depth of a tree. Do any of the depth first searches.
    In tree traversal inorder postorder and preorders all are different kinds of depth first searches.
    in postorder the observation is that a traversal while returning always returns to its parent.
    Hence if we are asked to traverse a tree without recursion, we may have to implement a stack by ourself, then
    postorder should be a good way to speed up returning calls
    (better and serialized nodes locality while poping from stack)


Counting set bits in a number:
huge discussion:
    http://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer



hex(input as string) to decimal.
say input is 0xABAB.
have a 256 byte array. array index 55 ['7'] would contain 7
                       array index 56 ['8'] would contain 8
                       array index 57 ['9'] would contain 9  ...
                       array index 65 ['A'] would contain 10
                       array index 66 ['B'] would contain 11
                       array index 67 ['C'] would contain 12
                       array index 68 ['D'] would contain 13
                       array index 69 ['E'] would contain 14 ...
                       array index 97 ['a'] would contain 10
                       array index 98 ['b'] would contain 11
                       array index 99 ['c'] would contain 12 ...
go through the string. for every byte, lookup the array for the corresponding value.
shift left the previous value 4 bits and OR the new value. finally we get the decimal value
Only 16 + 6 places would have useful values all other indices would be wasted.


Multiplying polynomials:
	use a 2D matrix. put polynomial co-efficients on each axis. multiply and put the values in the
	different cells of the matrix. add the cell values diagonally from SW to NE. each SW to NE path would
	have coefficients for a perticular power of x


links:
http://jonisalonen.com/2013/sorting-a-linked-list/
http://stackoverflow.com/questions/1525117/whats-the-fastest-algorithm-for-sorting-a-linked-list
http://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer



Stuff to learn:
===============
Counting sort: ??
Radix sort:
natural sort:
Merge sort: get the algo better
Skip Lists: learn again
heaps: min heaps, max heaps
a good DFS and BFS implementation




















